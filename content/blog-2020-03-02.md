+++
title = "This Week In Veloren 57"
description = ""

date = 2020-03-02
weight = 0
slug = "devblog-57"

[extra]
banner = "https://media.discordapp.net/attachments/541307708146581519/684534142276337820/xhnDuDT.png"

[taxonomies]
tags = ["devblog"]
+++

\- AngelOnFira, TWiV Editor

# Contributor Work

Thanks to this week's contributors, @Lorage, @xMAC94x, @AngelOnFira, @Artem, @imbris, and @Shandley!

@Kalculate is working through the NPC spawn code to fix spawn camping issues. Some of the core developers are working on figuring out a suitable modding language to handle animations. This is being headed up by @Zesterer and @imbris. @xMAC94x worked on automating Docker builds for the game server and Torvus. He is also working on networking systems and benchmarking them. @untouchedhappiness is working on Japanese translations.

{{ img(src="https://cdn.discordapp.com/attachments/597826574095613962/683702810650607632/troll1.png", caption="New mob by @Shimox") }}

# New Networking Protocol by @xMAC94x

The new networking protocol will add some layers above a simple TCP stream. The most basic TCP benchmark would contain of 2 programs, one is running and listening on a local port, the other one connects to it. After the connection is made the client just sends a ton of bytes, the server reads the bytes (and throws them away afterwards). You can then measure how much bytes the clients could send in a minute and then calc the MB/s throughput.

For TCP networking basically 2 factors are important:

1. The number of Bytes/s
2. The number of messages/s (as you can either send fewer big or alot small messages, big messages are faster)

{{ img(src="https://media.discordapp.net/attachments/467861553178345502/682852764069396485/redhead-orc-looks-at-you.png", caption="When mom says you're a handsome boy")}}

Simple TCP Networking has some disadvantes though, the mayor 2 being:

- It cannot make use of faster but unreliable UDP
- when a big message, like a Chunk comes in, all other messages have to wait (high ping)

Thats where velorens new network protocol will fit in. It allows an abstraction over multiple Protocols at once, TCP, UDP, and direct mpsc channels. The Networking Layer knows which Ports belong to the same Participant (=Client or Server) and can send messages of the most efficient way. Also big message are split up into smaller parts which can be send with a respective priority.

The stack is quite complicated and for the first time during development i got it in a working state for a minimal example.
That means, only 1 client each, only 1 protocol each (TCP) and only a single Stream of Messages.
As i already spend some time in developing this stack, before investing time in continuing adding more protocols or more clients i wanted to test the performance, because if my way should prove to be inefficient, i could adjust it directly.
Thats why a benchmark at an early stage sometimes is a reasonable choice.

{{ img(src="https://cdn.discordapp.com/attachments/634860358623821835/682910605480427549/18.png") }}

So what does the benchmark do? It's 1 program, that can be either client or server (depending on the command line arguments). A will start the server and listen in a sperate Thread for messages. B will connect to it and will start sending messages in a seperate Thread. The first result is: It doesn't crash, which means we have an integrated Pentest (or how i like to call it, Yuri-Test :wink: )

Every Message is a simple ID, which increases, plus 1000 bytes of zeros (just to give it some work). These messages will be encoded and decoded 2 times, once when sending them. This allows the framework to handle messages like a large collection of bytes. Thiese bytes will then be send to the networking layer were routing and decissions are done. When the networking layer decides the TCP layer is ready to send, it takes a small part of the messages and brings it to the tcp layer. Where it gets encoded a second time. The messages is send to the other side. At the other side the stack is applied backwards, it will get decoded, routed to the client and decoded again. In the end we get around 100.000 messages per second and about 800 Mbit/s. For a single client both results are not bad, they are more than veloren will ever need. But they are far from perfect compared to the big players in networking. So there are 2 things to do in the future:

1. Increase those numbers, to more like 500.000 messages/s and multiple Gbit/s
2. Focus on multiple clients, sending and receiving as this will be similar to the workload of a real veloren server

# Contributor Spotlight: Songtronix

Hey everyone, @Songtronix here! I started working on Veloren in mid-Feburary 2019. I found it while exploring the Rust community on Reddit/the web. Veloren was linked, which I checked out. I'm a 20 year old guy living in Germany. I strive to learn more about what interests me: **code**, **UI/UX/Graphic Design**, and music/video production).

I'm the guy behind airshipper, the Veloren launcher! It looked very frustrating if you have to explain for the 10x time on how to download the latest version of Veloren and as such I've tasked myself to ease the experience all around Veloren. I've made a download page which has the latest and greatest version of Veloren. I've made the launcher which currently does it's job of automating the updating experience.

Written in one of the best languages, Rust, Veloren as an open source project opened me up to a lot of possibilities to improve myself on. I learn to work together with people who have different skill sets than me, learn to make a compromise but also bring in my own view of things and challenging myself to grow beyond my skills.

I want to make Veloren a first class experience, not necessarily ingame but all around it. The book and the documentation, the onboarding process in making your first contribution and so much more ^^

{{ img(src="https://media.discordapp.net/attachments/634860358623821835/683401419465818124/veloren-voxygen_2020-02-29_20-51-58.png", caption="Sunset. See you next week!) }}
